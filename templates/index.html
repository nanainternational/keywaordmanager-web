<!doctype html>
<html lang="ko">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <title>키워드 매니저</title>

  <!-- FullCalendar -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.15/index.global.min.css">
  <script src="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.15/index.global.min.js"></script>

  <style>
    :root{
      --bg:#0b0f14;
      --panel:#0f1620;
      --panel2:#0d131c;
      --border:#1b2a3a;
      --text:#e7eef7;
      --muted:#8aa0b7;
      --brand:#4aa3ff;
      --danger:#ff5c6c;
      --shadow: 0 12px 30px rgba(0,0,0,.35);
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Noto Sans KR, Arial, sans-serif;
      background: radial-gradient(900px 500px at 50% -200px, rgba(74,163,255,.25), transparent 65%), var(--bg);
      color:var(--text);
      -webkit-tap-highlight-color: transparent;
    }
    .wrap{
      max-width: 980px;
      margin: 0 auto;
      padding: 14px 14px 18px;
    }
    .header{
      display:flex;
      align-items:flex-end;
      justify-content:space-between;
      gap:12px;
      margin: 8px 2px 14px;
    }
    .header h1{
      margin:0;
      font-size: 16px;
      font-weight: 700;
      letter-spacing:.2px;
    }
    .header .sub{
      font-size: 12px;
      color: var(--muted);
      font-weight: 300;
    }
    .grid{
      display:grid;
      grid-template-columns: 1fr;
      gap: 14px;
    }
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,.01)), var(--panel);
      border:1px solid var(--border);
      border-radius: 16px;
      box-shadow: var(--shadow);
      padding: 12px;
      overflow:hidden;
    }

    .section-title {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin: 2px 2px 10px;
    }
    .section-title h3 {
      margin: 0;
      font-size: 14px;
      font-weight: 600;
      letter-spacing: .15px;
    }

    button.mini {
      width: auto;
      padding: 7px 10px;
      border-radius: 10px;
      font-size: 12px;
      font-weight: 600;
      white-space: nowrap;
      flex: 0 0 auto;
    }

    /* ✅ 채팅 */
    .chat-box {
      height: 220px;
      overflow: auto;
      background: var(--panel2);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px;
      margin-bottom: 10px;
      scroll-behavior: smooth;
    }
    .msg {
      display:flex;
      gap:8px;
      align-items:flex-start;
      margin: 0 0 10px;
    }
    .msg:last-child{ margin-bottom:0; }
    .bubble{
      max-width: 84%;
      padding: 8px 10px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,.02);
    }
    .meta{
      font-size: 11px;
      color: var(--muted);
      margin-bottom: 4px;
      font-weight: 300;
    }
    .text{ font-size: 13px; white-space: pre-wrap; line-height: 1.45; }
    .me .bubble{
      margin-left:auto;
      background: rgba(74,163,255,.10);
      border-color: rgba(74,163,255,.35);
    }
    .me{ justify-content:flex-end; }
    .chat-input-row{
      display:grid;
      grid-template-columns: 90px 1fr 80px;
      gap: 8px;
      align-items:center;
    }
    input, textarea, select{
      width:100%;
      background: var(--panel2);
      border: 1px solid var(--border);
      color: var(--text);
      border-radius: 12px;
      padding: 10px 11px;
      font-size: 13px;
      outline:none;
      min-width: 0;
    }
    textarea{ min-height: 88px; resize: vertical; }
    input::placeholder, textarea::placeholder{ color: rgba(138,160,183,.65); }
    button{
      width:100%;
      border: 1px solid rgba(74,163,255,.45);
      background: rgba(74,163,255,.18);
      color: var(--text);
      border-radius: 12px;
      padding: 10px 12px;
      font-size: 13px;
      font-weight: 700;
      cursor: pointer;
      user-select:none;
    }
    button:disabled{
      opacity:.55;
      cursor:not-allowed;
    }
    .btn-danger{
      border-color: rgba(255,92,108,.55);
      background: rgba(255,92,108,.16);
    }
    .btn-ghost{
      border-color: rgba(138,160,183,.35);
      background: rgba(255,255,255,.02);
    }
    .row{
      display:flex;
      gap:8px;
      align-items:center;
    }
    .row > *{ flex:1; }

    /* ✅ 메모 */
    .memo-list{
      display:flex;
      flex-direction:column;
      gap: 10px;
      margin-top: 10px;
    }
    .memo-item{
      background: rgba(255,255,255,.02);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 10px 10px 10px;
    }
    .memo-top{
      display:flex;
      gap:8px;
      align-items:center;
      justify-content:space-between;
      margin-bottom: 6px;
    }
    .memo-time{
      font-size: 11px;
      color: var(--muted);
      font-weight: 300;
      white-space:nowrap;
    }
    .memo-actions{
      display:flex;
      gap:6px;
      align-items:center;
    }
    .mini{
      padding: 7px 10px;
      font-size: 12px;
      border-radius: 10px;
      width: auto;
    }
    .memo-body{
      font-size: 13px;
      white-space: pre-wrap;
      line-height: 1.45;
    }
    .memo-form textarea{
      min-height: 64px;
    }

    /* ✅ 캘린더 */
    #calendar{
      background: rgba(255,255,255,.01);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 8px;
      min-height: 660px;
      overflow:hidden;
    }
    .fc{
      --fc-border-color: rgba(27,42,58,.8);
      --fc-neutral-bg-color: rgba(255,255,255,.02);
      --fc-page-bg-color: transparent;
      --fc-today-bg-color: rgba(70,211,154,.10);
      --fc-button-bg-color: rgba(74,163,255,.18);
      --fc-button-border-color: rgba(74,163,255,.45);
      --fc-button-text-color: var(--text);
      --fc-button-active-bg-color: rgba(74,163,255,.28);
      --fc-button-active-border-color: rgba(74,163,255,.65);
      --fc-button-hover-bg-color: rgba(74,163,255,.25);
      --fc-button-hover-border-color: rgba(74,163,255,.65);
      --fc-event-bg-color: rgba(74,163,255,.16);
      --fc-event-border-color: rgba(74,163,255,.45);
      --fc-event-text-color: var(--text);
      color: var(--text);
    }
    .fc .fc-toolbar-title{ font-size: 14px; font-weight: 700; }
    .fc .fc-button{ border-radius: 10px; padding: 8px 10px; font-size: 12px; }
    .fc .fc-daygrid-day-number{ color: rgba(231,238,247,.9); font-size: 12px; font-weight: 300; }
    .fc .fc-col-header-cell-cushion{ color: rgba(138,160,183,.95); font-size: 12px; font-weight: 500; }
    .fc .fc-timegrid-slot-label-cushion{ font-size: 11px; color: rgba(138,160,183,.95); font-weight: 300; }
    .fc .fc-timegrid-axis-cushion{ font-size: 11px; color: rgba(138,160,183,.95); font-weight: 300; }
    .fc .fc-event-title{ font-size: 12px; font-weight: 600; }
    .fc .fc-event-time{ display:none; } /* 혹시라도 남는 시간표시 숨김 */

    /* ✅ 모달 */
    .modal-backdrop{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,.55);
      display:none;
      align-items:center;
      justify-content:center;
      padding: 18px;
      z-index: 9999;
    }
    .modal{
      width: 100%;
      max-width: 520px;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 16px;
      box-shadow: var(--shadow);
      padding: 12px;
    }
    .modal h4{
      margin: 4px 2px 10px;
      font-size: 14px;
      font-weight: 700;
    }
    .modal .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    .modal .span2{ grid-column: span 2; }
    .modal .actions{
      display:flex;
      gap: 8px;
      margin-top: 10px;
    }
    .tag{
      display:inline-flex;
      gap:6px;
      align-items:center;
      font-size: 11px;
      font-weight: 300;
      color: var(--muted);
      margin: 6px 0 6px;
    }

    /* 모바일 최적화 */
    @media (max-width: 480px) {
      .wrap { padding: 10px 10px 14px; }
      .card { padding: 10px; border-radius: 14px; }
      .chat-input-row { grid-template-columns: 76px 1fr 66px; }
      .chat-box { height: 200px; }
      #calendar { min-height: 620px; }
      .fc .fc-toolbar { flex-wrap: wrap; gap: 6px; }

      /* ✅ 모바일에서 "끝(선택)" 등 폼이 벗어나는 문제 해결: 1열 스택 */
      .modal .grid2 { grid-template-columns: 1fr; }
      .modal .span2 { grid-column: auto; }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="header">
      <div>
        <h1>키워드 매니저</h1>
        <div class="sub">Flask + Render + Supabase(Postgres)</div>
      </div>
      <div class="sub" id="statusText"></div>
    </div>

    <div class="grid">
      <!-- ✅ 채팅 -->
      <div class="card">
        <div class="section-title">
          <h3>채팅</h3>
        </div>

        <div class="chat-box" id="chatBox" aria-label="채팅 로그"></div>

        <div class="chat-input-row">
          <input id="chatSender" placeholder="이름" maxlength="20" value="허니걸">
          <input id="chatInput" placeholder="메시지 입력" maxlength="500">
          <button id="chatSendBtn" type="button">전송</button>
        </div>
      </div>

      <!-- ✅ 메모 -->
      <div class="card">
        <div class="section-title">
          <h3>메모</h3>
          <button class="mini" id="refreshMemosBtn" type="button">새로고침</button>
        </div>

        <form class="memo-form" id="memoForm" method="post" action="/">
          <textarea name="memo_text" id="memoText" placeholder="메모를 입력하세요"></textarea>
          <div class="row" style="margin-top: 8px;">
            <button type="submit">메모 저장</button>
          </div>
        </form>

        <div class="memo-list" id="memoList">
          {% for m in memos %}
          <div class="memo-item" data-id="{{ m.id }}">
            <div class="memo-top">
              <div class="memo-time">{{ m.created_at }}</div>
              <div class="memo-actions">
                <button class="mini btn-ghost" type="button" onclick="editMemo({{ m.id }})">수정</button>
                <button class="mini btn-danger" type="button" onclick="deleteMemo({{ m.id }})">삭제</button>
              </div>
            </div>
            <div class="memo-body" id="memoBody{{ m.id }}">{{ m.text }}</div>
          </div>
          {% endfor %}
        </div>
      </div>

      <!-- ✅ 캘린더 -->
      <div class="card">
        <div class="section-title" style="margin: 6px 2px 10px;">
          <h3>캘린더</h3>
          <button class="mini" id="refreshCalendarBtn" type="button">새로고침</button>
        </div>

        <div id="calendar"></div>
      </div>
    </div>
  </div>

  <!-- ✅ 일정 모달 -->
  <div class="modal-backdrop" id="eventModal">
    <div class="modal">
      <h4 id="modalTitle">일정</h4>
      <form id="eventForm">
        <div class="grid2">
          <div class="span2">
            <input id="evTitle" placeholder="제목" maxlength="200" required>
          </div>

          <div>
            <div class="tag">시작</div>
            <input id="evStart" type="datetime-local" required>
          </div>

          <div>
            <div class="tag">끝(선택)</div>
            <input id="evEnd" type="datetime-local">
          </div>

          <div class="span2">
            <div class="tag">메모(선택)</div>
            <textarea id="evMemo" placeholder="메모"></textarea>
          </div>

          <div class="span2">
            <label class="tag">
              <input id="evAllDay" type="checkbox" style="width:auto; margin-right:6px;">
              종일
            </label>
          </div>
        </div>

        <div class="actions">
          <button id="evSave" type="submit">저장</button>
          <button id="evDelete" class="btn-danger" type="button" style="display:none;">삭제</button>
          <button id="evCancel" class="btn-ghost" type="button">닫기</button>
        </div>
      </form>
    </div>
  </div>

  <script>
    async function jget(url) {
      const r = await fetch(url, { credentials: "include" });
      return await r.json();
    }
    async function jpost(url, bodyObj) {
      const r = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(bodyObj),
        credentials: "include",
      });
      return await r.json();
    }
    async function jput(url, bodyObj) {
      const r = await fetch(url, {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(bodyObj),
        credentials: "include",
      });
      return await r.json();
    }
    async function jdel(url) {
      const r = await fetch(url, { method: "DELETE", credentials: "include" });
      return await r.json();
    }

    const statusText = document.getElementById("statusText");
    function setStatus(msg) { if (statusText) statusText.textContent = msg || ""; }

    // =========================
    // ✅ 채팅
    // =========================
    const CHAT_ROOM = "main";
    const chatBox = document.getElementById("chatBox");
    const chatInput = document.getElementById("chatInput");
    const chatSender = document.getElementById("chatSender");
    const chatSendBtn = document.getElementById("chatSendBtn");

    let lastChatId = 0;

    function escapeHtml(s){
      return (s||"")
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#039;");
    }

    function appendMsg(m){
      const wrap = document.createElement("div");
      const isMe = (m.sender || "").trim() === (chatSender.value || "").trim();
      wrap.className = "msg" + (isMe ? " me" : "");

      const bubble = document.createElement("div");
      bubble.className = "bubble";

      const meta = document.createElement("div");
      meta.className = "meta";
      meta.textContent = `${m.sender || "익명"} · ${m.created_at || ""}`;

      const text = document.createElement("div");
      text.className = "text";
      text.innerHTML = escapeHtml(m.message || "");

      bubble.appendChild(meta);
      bubble.appendChild(text);
      wrap.appendChild(bubble);
      chatBox.appendChild(wrap);

      chatBox.scrollTop = chatBox.scrollHeight;
    }

    async function loadChatInit(){
      try{
        const data = await jget(`/api/chat/messages?room=${encodeURIComponent(CHAT_ROOM)}&after_id=0`);
        if (data && data.ok && Array.isArray(data.messages)) {
          chatBox.innerHTML = "";
          for (const m of data.messages) {
            appendMsg(m);
            lastChatId = Math.max(lastChatId, m.id);
          }
        }
      }catch(e){}
    }

    async function pollChatOnce() {
      const data = await jget(`/api/chat/messages?room=${encodeURIComponent(CHAT_ROOM)}&after_id=${lastChatId}`);
      if (data && data.ok && Array.isArray(data.messages)) {
        for (const m of data.messages) {
          appendMsg(m);
          lastChatId = Math.max(lastChatId, m.id);
        }
      }
    }

    let chatPollTimer = null;

    async function pollChat() {
      if (chatPollTimer) clearTimeout(chatPollTimer);

      if (document.hidden) {
        chatPollTimer = setTimeout(pollChat, 5000);
        return;
      }

      try { await pollChatOnce(); } catch (e) {}

      chatPollTimer = setTimeout(pollChat, 2000);
    }

    document.addEventListener("visibilitychange", () => {
      if (!document.hidden) pollChat();
    });

    async function sendChat() {
      const sender = (chatSender.value || "익명").trim();
      const message = (chatInput.value || "").trim();
      if (!message) return;

      chatSendBtn.disabled = true;
      try{
        const data = await jpost(`/api/chat/messages`, { room: CHAT_ROOM, sender, message });
        if (data && data.ok) {
          chatInput.value = "";
          await pollChatOnce();
        }
      }catch(e){}
      chatSendBtn.disabled = false;
      chatInput.focus();
    }

    chatSendBtn.addEventListener("click", sendChat);
    chatInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        sendChat();
      }
    });

    // =========================
    // ✅ 메모 (수정/삭제)
    // =========================
    async function deleteMemo(id){
      if(!confirm("이 메모를 삭제할까요?")) return;
      try{
        const data = await jdel(`/api/memos/${id}`);
        if(data && data.ok){
          const el = document.querySelector(`.memo-item[data-id="${id}"]`);
          if(el) el.remove();
        }
      }catch(e){}
    }

    async function editMemo(id){
      const body = document.getElementById("memoBody" + id);
      if(!body) return;
      const current = body.textContent || "";
      const next = prompt("메모 수정", current);
      if(next === null) return;

      try{
        const data = await jput(`/api/memos/${id}`, { text: next });
        if(data && data.ok){
          body.textContent = next;
        }
      }catch(e){}
    }

    // =========================
    // ✅ 캘린더
    // =========================
    let calendar = null;

    const modal = document.getElementById("eventModal");
    const modalTitle = document.getElementById("modalTitle");
    const evForm = document.getElementById("eventForm");
    const evTitle = document.getElementById("evTitle");
    const evStart = document.getElementById("evStart");
    const evEnd = document.getElementById("evEnd");
    const evMemo = document.getElementById("evMemo");
    const evAllDay = document.getElementById("evAllDay");
    const evSave = document.getElementById("evSave");
    const evDelete = document.getElementById("evDelete");
    const evCancel = document.getElementById("evCancel");

    let currentEventId = null;

    function toLocalInputValue(dateObj){
      const d = new Date(dateObj);
      const pad = (n)=> String(n).padStart(2,"0");
      const yyyy = d.getFullYear();
      const mm = pad(d.getMonth()+1);
      const dd = pad(d.getDate());
      const hh = pad(d.getHours());
      const mi = pad(d.getMinutes());
      return `${yyyy}-${mm}-${dd}T${hh}:${mi}`;
    }

    function openModal(mode, info){
      modal.style.display = "flex";

      if(mode === "create"){
        currentEventId = null;
        modalTitle.textContent = "일정 추가";
        evTitle.value = "";
        evMemo.value = "";
        evAllDay.checked = false;

        evStart.value = info.startStr ? info.startStr.slice(0,16) : "";
        evEnd.value = info.endStr ? info.endStr.slice(0,16) : "";

        evDelete.style.display = "none";
      }else{
        currentEventId = info.id;
        modalTitle.textContent = "일정 수정";
        evTitle.value = info.title || "";
        evMemo.value = info.extendedProps?.memo || "";
        evAllDay.checked = !!info.allDay;

        evStart.value = info.start ? toLocalInputValue(info.start) : "";
        evEnd.value = info.end ? toLocalInputValue(info.end) : "";

        evDelete.style.display = "inline-block";
      }
    }

    function closeModal(){
      modal.style.display = "none";
    }

    function initCalendar(){
      const el = document.getElementById("calendar");
      calendar = new FullCalendar.Calendar(el, {
        initialView: "timeGridWeek",
        height: "auto",
        expandRows: true,
        nowIndicator: true,
        locale: "ko",
        firstDay: 1,
        selectable: true,
        editable: true,
        dayMaxEvents: true,

        timeZone: "Asia/Seoul",
        displayEventTime: false,

        headerToolbar: {
          left: "prev,next today",
          center: "title",
          right: "dayGridMonth,timeGridWeek,timeGridDay"
        },

        events: async (fetchInfo, success, failure) => {
          try{
            const data = await jget("/api/events");
            if (data && data.ok && Array.isArray(data.events)) {
              const out = data.events.map(e => ({
                id: e.id,
                title: e.title || "",
                start: e.start,
                end: e.end,
                allDay: !!e.all_day,
                extendedProps: { memo: e.memo || "" }
              }));
              success(out);
            } else {
              success([]);
            }
          }catch(err){
            failure(err);
          }
        },

        eventContent: function(arg) {
          const wrap = document.createElement("div");
          const title = document.createElement("div");
          title.textContent = arg.event.title || "";
          wrap.appendChild(title);
          return { domNodes: [wrap] };
        },

        select: (info) => {
          openModal("create", info);
        },

        eventClick: (info) => {
          openModal("edit", info.event);
        },

        eventDrop: async (info) => {
          try{
            await jput(`/api/events/${info.event.id}`, {
              title: info.event.title,
              start: info.event.start ? info.event.start.toISOString() : null,
              end: info.event.end ? info.event.end.toISOString() : null,
              all_day: !!info.event.allDay,
              memo: info.event.extendedProps?.memo || ""
            });
          }catch(e){}
        },

        eventResize: async (info) => {
          try{
            await jput(`/api/events/${info.event.id}`, {
              title: info.event.title,
              start: info.event.start ? info.event.start.toISOString() : null,
              end: info.event.end ? info.event.end.toISOString() : null,
              all_day: !!info.event.allDay,
              memo: info.event.extendedProps?.memo || ""
            });
          }catch(e){}
        }
      });

      calendar.render();
    }

    evCancel.addEventListener("click", (e)=>{ e.preventDefault(); closeModal(); });
    modal.addEventListener("click", (e)=>{ if(e.target === modal) closeModal(); });

    evForm.addEventListener("submit", async (e) => {
      e.preventDefault();
      e.stopPropagation();

      const title = (evTitle.value || "").trim();
      if(!title) return;

      const start = evStart.value ? new Date(evStart.value).toISOString() : null;
      const end = evEnd.value ? new Date(evEnd.value).toISOString() : null;
      const memo = (evMemo.value || "").trim();
      const all_day = !!evAllDay.checked;

      evSave.disabled = true;

      try{
        if(!currentEventId){
          await jpost("/api/events", { title, start, end, memo, all_day });
        }else{
          await jput(`/api/events/${currentEventId}`, { title, start, end, memo, all_day });
        }
        closeModal();
        if (calendar) calendar.refetchEvents();
      } catch (e2) {
      } finally {
        evSave.disabled = false;
      }
    });

    evDelete.addEventListener("click", async (e) => {
      e.preventDefault();
      e.stopPropagation();

      if (!currentEventId) return;
      if (!confirm("이 일정을 삭제할까요?")) return;

      evDelete.disabled = true;

      try {
        await jdel(`/api/events/${currentEventId}`);
        closeModal();
        if (calendar) calendar.refetchEvents();
      } catch (err) {
      } finally {
        evDelete.disabled = false;
      }
    });

    // =========================
    // ✅ 초기 로드
    // =========================
    (async function boot(){
      setStatus("연결 중...");
      await loadChatInit();
      pollChat();
      initCalendar();

      const refreshMemosBtn = document.getElementById("refreshMemosBtn");
      if (refreshMemosBtn) {
        refreshMemosBtn.addEventListener("click", () => window.location.reload());
      }

      const refreshCalendarBtn = document.getElementById("refreshCalendarBtn");
      if (refreshCalendarBtn) {
        refreshCalendarBtn.addEventListener("click", () => {
          if (calendar) calendar.refetchEvents();
        });
      }

      setStatus("");
    })();
  </script>
</body>
</html>
