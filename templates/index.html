<!doctype html>
<html lang="ko">
<head>
  <title>Keyword Manager</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#11172a;
      --panel2:#0f1526;
      --text:#e8ecf3;
      --muted:rgba(255,255,255,.65);
      --line:rgba(255,255,255,.08);
      --brand:#8b5cf6;
      --brand2:#22c55e;
      --danger:#ef4444;
      --chip:#1a223a;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background: radial-gradient(1000px 500px at 20% 10%, rgba(139,92,246,.18), transparent 60%),
                  radial-gradient(800px 400px at 90% 20%, rgba(34,197,94,.10), transparent 60%),
                  var(--bg);
      color:var(--text);
    }
    .wrap{max-width:1200px;margin:0 auto;padding:18px}
    .topbar{
      display:flex;align-items:center;justify-content:space-between;
      padding:14px 16px;border-radius:16px;
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid var(--line);
      box-shadow: var(--shadow);
      gap:12px;
    }
    .brand{
      font-weight:900;letter-spacing:-.2px;
      display:flex;align-items:center;gap:10px;
      font-size:18px;
    }
    .brand .dot{
      width:10px;height:10px;border-radius:50%;background:var(--brand);
      box-shadow:0 0 18px rgba(139,92,246,.8);
    }
    .tabs{display:flex;gap:8px;flex-wrap:wrap}
    .tab{
      border:1px solid var(--line);
      background:rgba(255,255,255,.03);
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
      font-weight:800;
      font-size:13px;
      user-select:none;
    }
    .tab.active{
      background:rgba(139,92,246,.18);
      border-color: rgba(139,92,246,.35);
    }
    .grid{
      margin-top:14px;
      display:grid;
      grid-template-columns: 1fr;
      gap:14px;
    }
    @media (min-width: 900px){
      .grid{grid-template-columns: 1fr 1fr 1fr}
    }
    .panel{
      background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border:1px solid var(--line);
      border-radius:18px;
      box-shadow: var(--shadow);
      padding:14px;
      min-height:360px;
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .panel h2{
      margin:0;
      font-size:14px;
      font-weight:900;
      color:rgba(255,255,255,.92);
      display:flex;align-items:center;justify-content:space-between;
      gap:10px;
    }
    .subactions{display:flex;gap:8px;flex-wrap:wrap}
    .btn{
      border:1px solid var(--line);
      background:rgba(255,255,255,.03);
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
      font-weight:900;
      font-size:12px;
      user-select:none;
      white-space:nowrap;
    }
    .btn.primary{
      background:rgba(139,92,246,.22);
      border-color: rgba(139,92,246,.40);
    }
    .btn.danger{
      background:rgba(239,68,68,.15);
      border-color: rgba(239,68,68,.35);
    }
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    input, textarea{
      width:100%;
      background:rgba(0,0,0,.22);
      border:1px solid var(--line);
      color:var(--text);
      padding:12px 12px;
      border-radius:14px;
      outline:none;
      font-size:13px;
    }
    textarea{min-height:90px;resize:vertical}
    .stack{display:flex;flex-direction:column;gap:10px}
    .small{font-size:12px;color:var(--muted)}
    .divider{height:1px;background:var(--line);margin:4px 0}
    .chat-log{
      flex:1;
      overflow:auto;
      border-radius:14px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.16);
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .msg{
      display:flex;flex-direction:column;gap:3px;
      padding:10px 10px;
      background:rgba(255,255,255,.03);
      border:1px solid rgba(255,255,255,.06);
      border-radius:14px;
    }
    .msg .meta{font-size:11px;color:var(--muted);display:flex;gap:8px;flex-wrap:wrap}
    .msg .text{font-size:13px;line-height:1.35}
    .msg.me{
      background:rgba(139,92,246,.14);
      border-color: rgba(139,92,246,.25);
    }
    .calendar{
      flex:1;
      overflow:auto;
      border-radius:14px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.16);
      padding:10px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .event{
      display:flex;flex-direction:column;gap:6px;
      padding:10px 10px;
      background:rgba(255,255,255,.03);
      border:1px solid rgba(255,255,255,.06);
      border-radius:14px;
    }
    .event .title{font-weight:900;font-size:13px}
    .event .dates{font-size:12px;color:var(--muted)}
    .event .memo{font-size:12px;color:rgba(255,255,255,.86);white-space:pre-wrap}
    .event .actions{display:flex;gap:8px;justify-content:flex-end}
    .presence-bar{
      display:flex;align-items:center;gap:10px;flex-wrap:wrap;
      padding:10px 12px;border-radius:14px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.16);
    }
    .presence-bar .dot{
      width:10px;height:10px;border-radius:50%;
      background:#3b82f6;
      box-shadow:0 0 12px rgba(59,130,246,.55);
    }

      .presence-pills{display:flex;flex-wrap:wrap;gap:8px}
      .pill{display:flex;align-items:center;gap:10px;padding:8px 10px;border-radius:999px;background:#1b1f2a;border:1px solid rgba(255,255,255,.06)}
      .pill.offline{opacity:.65}
      .avatar{position:relative;width:28px;height:28px;border-radius:50%;background:#2a3142;display:flex;align-items:center;justify-content:center;font-weight:800;font-size:12px;color:#fff;flex:0 0 28px}
      .status-dot{position:absolute;right:-2px;bottom:-2px;width:10px;height:10px;border-radius:50%;border:2px solid #111421;background:#6b7280}
      .status-dot.online{background:#3b82f6}
      .pill .meta{display:flex;flex-direction:column;line-height:1.1}
      .pill .name{font-weight:800;font-size:13px}
      .pill .time{font-size:11px;color:rgba(255,255,255,.7)}
      .presence-groups{display:flex;flex-direction:column;gap:10px}
      .presence-group-title{font-size:12px;color:rgba(255,255,255,.65);font-weight:700}

    .hidden{display:none !important}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="brand"><span class="dot"></span> Keyword Manager</div>
      <div class="tabs">
        <div class="tab active" data-tab="chat">메시지</div>
        <div class="tab" data-tab="memo">메모</div>
        <div class="tab" data-tab="calendar">캘린더</div>
      </div>
    </div>

    <div class="grid">
      <!-- Chat -->
      <div class="panel" id="panel-chat">
        <h2>
          메시지
          <div class="subactions">
            <button class="btn" id="chatRefreshBtn">새로고침</button>
          </div>
        </h2>

        <div class="presence-bar">
          <span class="dot"></span>
          <div class="small" style="font-weight:900">최근 접속자</div>
        </div>
        <div id="presenceList" class="small" style="margin-top:-6px;line-height:1.4;">-</div>

        <div class="stack">
          <div class="row">
            <input id="chatSender" placeholder="이름" value="">
          </div>
          <div class="chat-log" id="chatLog"></div>
          <div class="row">
            <input id="chatInput" placeholder="메시지 입력">
            <button class="btn primary" id="sendBtn">전송</button>
          </div>
          <div class="small">이름을 입력해야 채팅 전송/접속 표시가 활성화됩니다.</div>
        </div>
      </div>

      <!-- Memo -->
      <div class="panel hidden" id="panel-memo">
        <h2>
          메모
          <div class="subactions">
            <button class="btn" id="memoRefreshBtn">새로고침</button>
          </div>
        </h2>
        <textarea id="memoText" placeholder="메모를 작성하세요..."></textarea>
        <div class="row">
          <button class="btn primary" id="memoSaveBtn">저장</button>
          <button class="btn danger" id="memoClearBtn">삭제</button>
        </div>
        <div class="small" id="memoStatus"></div>
      </div>

      <!-- Calendar -->
      <div class="panel hidden" id="panel-calendar">
        <h2>
          캘린더
          <div class="subactions">
            <button class="btn" id="calendarRefreshBtn">새로고침</button>
          </div>
        </h2>
        <div class="calendar" id="calendarList"></div>

        <div class="divider"></div>

        <div class="stack">
          <input id="eventTitle" placeholder="일정 제목">
          <div class="row">
            <input id="eventStart" type="date">
            <input id="eventEnd" type="date">
          </div>
          <textarea id="eventMemo" placeholder="메모 (선택)"></textarea>
          <div class="row">
            <button class="btn primary" id="eventAddBtn">저장</button>
          </div>
          <div class="small" id="calendarStatus"></div>
        </div>
      </div>
    </div>
  </div>

<script>
  const tabs = document.querySelectorAll(".tab");
  const panels = {
    chat: document.getElementById("panel-chat"),
    memo: document.getElementById("panel-memo"),
    calendar: document.getElementById("panel-calendar")
  };

  tabs.forEach(t => {
    t.addEventListener("click", () => {
      tabs.forEach(x => x.classList.remove("active"));
      t.classList.add("active");
      const key = t.dataset.tab;
      Object.keys(panels).forEach(k => panels[k].classList.toggle("hidden", k !== key));
    });
  });

  function jget(url){
    return fetch(url, { credentials: "include" }).then(r => r.json());
  }
  function jpost(url, body){
    return fetch(url, {
      method:"POST",
      headers: {"Content-Type":"application/json"},
      credentials: "include",
      body: JSON.stringify(body || {})
    }).then(r => r.json());
  }

  const chatSender = document.getElementById("chatSender");
  const chatLog = document.getElementById("chatLog");
  const chatInput = document.getElementById("chatInput");
  const sendBtn = document.getElementById("sendBtn");
  const chatRefreshBtn = document.getElementById("chatRefreshBtn");

  const presenceList = document.getElementById("presenceList");

  const memoText = document.getElementById("memoText");
  const memoSaveBtn = document.getElementById("memoSaveBtn");
  const memoClearBtn = document.getElementById("memoClearBtn");
  const memoStatus = document.getElementById("memoStatus");
  const memoRefreshBtn = document.getElementById("memoRefreshBtn");

  const calendarList = document.getElementById("calendarList");
  const eventTitle = document.getElementById("eventTitle");
  const eventStart = document.getElementById("eventStart");
  const eventEnd = document.getElementById("eventEnd");
  const eventMemo = document.getElementById("eventMemo");
  const eventAddBtn = document.getElementById("eventAddBtn");
  const calendarStatus = document.getElementById("calendarStatus");
  const calendarRefreshBtn = document.getElementById("calendarRefreshBtn");

  const CHAT_ROOM = "main";
    // ✅ 이름(발신자) 저장/복원: 이름 입력 전에는 채팅 입력/전송을 막음
    const SAVED_SENDER = localStorage.getItem("chat_sender") || "";
    if (SAVED_SENDER && !chatSender.value.trim()) chatSender.value = SAVED_SENDER;

    function updateChatEnabled() {
      const sender = (chatSender.value || "").trim();
      const ok = sender.length > 0;
      chatInput.disabled = !ok;
      sendBtn.disabled = !ok;
      chatInput.placeholder = ok ? "메시지 입력" : "이름을 먼저 입력해주세요";
      if (ok) {
        localStorage.setItem("chat_sender", sender);
      }
    }

    chatSender.addEventListener("input", () => {
      updateChatEnabled();
    });

  // client_id
  let CLIENT_ID = localStorage.getItem("chat_client_id");
  if (!CLIENT_ID) {
    CLIENT_ID = "c_" + Math.random().toString(36).slice(2) + "_" + Date.now();
    localStorage.setItem("chat_client_id", CLIENT_ID);

    // ✅ 동물 별칭(귀여운 표시용)
    const ANIMAL_KEY = "chat_animal";
    const animals = ["토끼","고양이","강아지","여우","호랑이","곰","펭귄","사자","기린","다람쥐"];
    let ANIMAL_ALIAS = localStorage.getItem(ANIMAL_KEY);
    if (!ANIMAL_ALIAS) {
      ANIMAL_ALIAS = animals[Math.floor(Math.random() * animals.length)];
      localStorage.setItem(ANIMAL_KEY, ANIMAL_ALIAS);
    }
  }
  // ANIMAL_ALIAS는 항상 존재하도록
  const ANIMAL_ALIAS = localStorage.getItem("chat_animal") || "토끼";

  let lastChatId = 0;
  let chatTimer = null;
  let presenceTimer = null;
  let presencePingTimer = null;

  function escapeHtml(s){
    return String(s || "").replace(/[&<>"']/g, m => ({
      "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"
    }[m]));
  }

  function formatTime(iso){
    try {
      const d = new Date(iso);
      const hh = String(d.getHours()).padStart(2,"0");
      const mm = String(d.getMinutes()).padStart(2,"0");
      return `${hh}:${mm}`;
    } catch(e){ return ""; }
  }

  async function pollChat(){
    try {
      const data = await jget(`/api/chat/messages?room=${encodeURIComponent(CHAT_ROOM)}&after_id=${lastChatId}`);
      if (!data || !data.ok) return;
      const msgs = data.messages || [];
      if (msgs.length) {
        msgs.forEach(addChatMsg);
        lastChatId = msgs[msgs.length-1].id;
        chatLog.scrollTop = chatLog.scrollHeight;
      }
    } catch(e){}
  }

  function addChatMsg(m){
    const sender = m.sender || "";
    const message = m.message || "";
    const created = m.created_at || "";

    const myName = (chatSender.value || "").trim();
    const isMe = myName && sender === myName;

    const el = document.createElement("div");
    el.className = "msg" + (isMe ? " me" : "");
    el.innerHTML = `
      <div class="meta">
        <span style="font-weight:900;color:rgba(255,255,255,.85)">${escapeHtml(sender)}</span>
        <span>${escapeHtml(formatTime(created))}</span>
      </div>
      <div class="text">${escapeHtml(message)}</div>
    `;
    chatLog.appendChild(el);
  }

  async function sendChat(){
    const sender = (chatSender.value || "").trim();
      if (!sender) { alert("이름을 입력해주세요"); updateChatEnabled(); return; }
    const message = (chatInput.value || "").trim();
    if (!message) return;

    const res = await jpost("/api/chat/send", {
      room: CHAT_ROOM,
      sender,
      message
    });

    if (res && res.ok) {
      chatInput.value = "";
      pollChat();
    }
  }

  sendBtn.addEventListener("click", sendChat);
  chatInput.addEventListener("keydown", (e) => {
    if (e.key === "Enter") sendChat();
  });
  chatRefreshBtn.addEventListener("click", () => {
    lastChatId = 0;
    chatLog.innerHTML = "";
    pollChat();
  });

    function _presenceSender() {
      return (chatSender?.value || "").trim();
    }

    function _formatAgoMinutes(mins) {
      if (mins < 0) mins = 0;
      if (mins < 60) return `${mins}분전`;
      const h = Math.floor(mins / 60);
      if (h < 24) return `${h}시간전`;
      const d = Math.floor(h / 24);
      return `${d}일전`;
    }

    function _initialFromName(name) {
      const n = (name || "").trim();
      if (!n) return "?";
      // 한글/영문/숫자 모두 첫 글자만
      return n[0].toUpperCase();
    }

    function _renderPresence(users) {
      const now = Date.now();
      const ONLINE_MIN = 2;

      // sender 기준으로 병합(같은 사람이 여러 client_id일 때 최신 1개만)
      const bySender = new Map();
      for (const u of users) {
        const sender = (u.sender || "").trim();
        if (!sender) continue; // 이름 없는건 표시 안함
        const t = u.last_seen ? new Date(u.last_seen).getTime() : 0;
        const prev = bySender.get(sender);
        if (!prev || t > (prev._t || 0)) {
          bySender.set(sender, { ...u, sender, _t: t });
        }
      }

      const merged = Array.from(bySender.values())
        .sort((a, b) => (b._t || 0) - (a._t || 0));

      const online = [];
      const offline = [];

      for (const u of merged) {
        const mins = u._t ? Math.floor((now - u._t) / 60000) : 999999;
        const isOnline = mins < ONLINE_MIN;
        const item = { ...u, _mins: mins, _online: isOnline };
        (isOnline ? online : offline).push(item);
      }

      function pill(u) {
        const animal = (u.animal || "").trim();
        const showName = u.sender || "익명";
        const timeText = u._online ? "접속중" : _formatAgoMinutes(u._mins);
        return `
          <div class="pill ${u._online ? "" : "offline"}">
            <div class="avatar">
              ${escapeHtml(_initialFromName(showName))}
              <span class="status-dot ${u._online ? "online" : ""}"></span>
            </div>
            <div class="meta">
              <div class="name">${escapeHtml(showName)}${animal ? ` <span style="opacity:.75;font-weight:700">(${escapeHtml(animal)})</span>` : ""}</div>
              <div class="time">${escapeHtml(timeText)}</div>
            </div>
          </div>
        `;
      }

      const onlineHtml = online.length
        ? `<div class="presence-group-title">접속중</div><div class="presence-pills">${online.map(pill).join("")}</div>`
        : `<div class="presence-group-title">접속중</div><div style="opacity:.6;font-size:12px">없음</div>`;

      const offlineHtml = offline.length
        ? `<div class="presence-group-title">비접속중</div><div class="presence-pills">${offline.map(pill).join("")}</div>`
        : `<div class="presence-group-title">비접속중</div><div style="opacity:.6;font-size:12px">없음</div>`;

      presenceList.innerHTML = `<div class="presence-groups">${onlineHtml}${offlineHtml}</div>`;
    }

    async function presencePing() {
      const sender = _presenceSender();
      if (!sender) return; // 이름 입력 전엔 기록 안남김
      try {
        await jpost("/api/presence/ping", { client_id: CLIENT_ID, sender, animal: ANIMAL_ALIAS });
      } catch (e) {}
    }

    async function presenceRefresh() {
      try {
        // 최대 1일(1440분) 범위로 최근 접속자 목록 조회
        const data = await jget("/api/presence/list?minutes=1440");
        if (!data || !data.ok) return;

        const users = (data.users || []).map(u => ({
          client_id: (u.client_id || ""),
          sender: (u.sender || ""),
          animal: (u.animal || ""),
          last_seen: (u.last_seen || null)
        }));

        _renderPresence(users);
      } catch (e) {}
    }

    function startPresence() {
      if (presenceTimer) clearInterval(presenceTimer);
      if (presencePingTimer) clearInterval(presencePingTimer);

      presenceRefresh();
      presencePing();

      // 25초마다 접속 유지 신호 (이름 입력된 경우에만)
      presencePingTimer = setInterval(() => {
        if (!document.hidden) presencePing();
      }, 25000);

      // 10초마다 목록 갱신
      presenceTimer = setInterval(() => {
        if (!document.hidden) presenceRefresh();
      }, 10000);
    }

  // -----------------------------
  // Memo (localStorage 기반)
  // -----------------------------
  const MEMO_KEY = "memo_text";
  function loadMemo(){
    memoText.value = localStorage.getItem(MEMO_KEY) || "";
    memoStatus.textContent = "불러옴";
    setTimeout(()=>memoStatus.textContent="", 1200);
  }
  function saveMemo(){
    localStorage.setItem(MEMO_KEY, memoText.value || "");
    memoStatus.textContent = "저장됨";
    setTimeout(()=>memoStatus.textContent="", 1200);
  }
  function clearMemo(){
    memoText.value = "";
    localStorage.removeItem(MEMO_KEY);
    memoStatus.textContent = "삭제됨";
    setTimeout(()=>memoStatus.textContent="", 1200);
  }
  memoSaveBtn.addEventListener("click", saveMemo);
  memoClearBtn.addEventListener("click", clearMemo);
  memoRefreshBtn.addEventListener("click", loadMemo);

  // -----------------------------
  // Calendar
  // -----------------------------
  async function loadCalendar(){
    calendarStatus.textContent = "";
    try{
      const data = await jget("/api/events");
      if (!data || !data.ok) return;
      const events = data.events || [];
      renderCalendar(events);
    }catch(e){
      calendarStatus.textContent = "불러오기 실패";
    }
  }

  function renderCalendar(events){
    calendarList.innerHTML = "";
    if (!events.length){
      const empty = document.createElement("div");
      empty.className = "small";
      empty.style.opacity = ".7";
      empty.textContent = "일정이 없습니다.";
      calendarList.appendChild(empty);
      return;
    }

    events.forEach(ev=>{
      const el = document.createElement("div");
      el.className = "event";
      el.innerHTML = `
        <div class="title">${escapeHtml(ev.title)}</div>
        <div class="dates">${escapeHtml(ev.start_date)} ~ ${escapeHtml(ev.end_date)}</div>
        ${ev.memo ? `<div class="memo">${escapeHtml(ev.memo)}</div>` : ""}
        <div class="actions">
          <button class="btn danger" data-del="${ev.id}">삭제</button>
        </div>
      `;
      el.querySelector("[data-del]").addEventListener("click", async ()=>{
        await fetch(`/api/events/${ev.id}`, {method:"DELETE", credentials:"include"});
        loadCalendar();
      });
      calendarList.appendChild(el);
    });
  }

  async function addCalendar(){
    const title = (eventTitle.value || "").trim();
    const start_date = (eventStart.value || "").trim();
    const end_date = (eventEnd.value || "").trim();
    const memo = (eventMemo.value || "").trim();

    if (!title || !start_date || !end_date){
      calendarStatus.textContent = "제목/시작/끝 날짜는 필수입니다.";
      return;
    }

    calendarStatus.textContent = "저장중...";
    const res = await jpost("/api/events", {title, start_date, end_date, memo});
    if (res && res.ok){
      eventTitle.value = "";
      eventMemo.value = "";
      calendarStatus.textContent = "저장됨";
      loadCalendar();
      setTimeout(()=>calendarStatus.textContent="", 1200);
    }else{
      calendarStatus.textContent = "저장 실패";
    }
  }

  eventAddBtn.addEventListener("click", addCalendar);
  calendarRefreshBtn.addEventListener("click", loadCalendar);

  // init
  function startChatPolling(){
    if (chatTimer) clearInterval(chatTimer);
    pollChat();
    chatTimer = setInterval(()=>{ if (!document.hidden) pollChat(); }, 4000);
  }

  updateChatEnabled();
    pollChat();
    startChatPolling();
    startPresence();
    loadMemo();
    loadCalendar();
</script>
</body>
</html>
